# This configuration file is adapted from XENON100.ini for the Münster TPC
# It will contain MünsterTPC-specific details
# date: Aug 26th 2015
# editor : Axel Buß

# This config contains the gain calibrated values of Julian B.'s measurements with a green LED at room temperature
[pax]
parent_configuration = "_base"
plugin_paths = ['examples/muenster']

input = 'EVE_file.EveInput'
#show_waveforms = ['ShowWaveforms.PlotAllChannels']
#output = 'Plotting.PlotEventSummary'
# Global settings, passed to every plugin
dsp = [
            # Do some sanity checks / cleaning on pulses
            #'CheckPulses.SortPulses',
            'CheckPulses.ConcatenateAdjacentPulses',
            'CheckPulses.CheckBounds',

            # Find individual hits
            'HitFinder.FindHits',
            # Combine hits into rough clusters = peaks
            'BuildPeaks.GapSizeClustering',

            # Reject hits in noisy channels
            'RejectNoiseHits.RejectNoiseHits',
            'SumWaveform.SumWaveform',



            # Compute sum-waveform and hit-dependent properties for each peak
            'BasicProperties.BasicProperties',
            'BasicProperties.SumWaveformProperties',
      # 'BasicProperties.CountCoincidentNoisePulses'
        ]

# Compute peak properties: can be redone from processed data file
compute_properties = [
#                        'WeightedSum.PosRecWeightedSum',
                         'MaxPMT.PosRecMaxPMT',
#                        'RobustWeightedMean.PosRecRobustWeightedMean',
#                        'NeuralNet.PosRecNeuralNet',
#                        'ChiSquareGamma.PosRecChiSquareGamma',
#                        'HitpatternSpread.HitpatternSpread',
                     ]

# Final stage with 'risky' operations: peak classification, S1/S2 pairing, corrections
# Intentionally last, so reclassification takes least work
pre_analysis = [
                # Classify the clusters based on the properties
                'ClassifyPeaks.AdHocClassification',

                # Combine S1 and S2 into pairs = interactions and compute properties
                # which depend on S1 AND S2 specific information (i.e. z-corrections)
                'BuildInteractions.BuildInteractions',
                'BuildInteractions.BasicInteractionProperties',
               ]
pre_output = []
#output = 'ROOTClass.WriteROOTClass'
output = 'Table.TableWriter'

[DEFAULT]
tpc_name = "MuensterTPC"

# Time in the event at which trigger occurs. Set to None or leave out if there is no trigger
trigger_time_in_event = 2560 * ns    # Check settings in caen1724.par

pmt_0_is_fake = False

# Detector specification
# PlotChannelWaveform2D expects the detector names' lexical order to be the same as the channel order
channels_in_detector = {
    'tpc':   list(range(14)),
    }
n_channels = 14		# 2x v1724

# PMT numbers for tpc, specified as lists

channels_top = list(range(0,  7))
channels_bottom = list(range(7, 14))

# PMT locations taken from technical drawing of Muenster TPC
# Whether they are in correct order has to be confirmed yet
tpc_length = 17 * cm
tpc_radius = 4 * cm

electron_lifetime_liquid =            450 * us           # AmBe Run12 mean value, see e.g. xenon1t:sim:notes:morana:ambe:nest
drift_velocity_liquid     =           1.73 * um / ns     # Andrea says 1.73 um/ns. Ethan's code has 1.8 mm/us.


# PMT numbers for tpc, specified as lists
# Remember python range does not include endpoint!

pmts = [{"array": "bottom",
         "pmt_position": 0,
         "position": {"y": -1.450, "x": -2.900}},
        {"array": "bottom",
         "pmt_position": 1,
         "position": {"y": 1.450, "x": -2.900}},
        {"array": "bottom",
         "pmt_position": 2,
         "position": {"y": 2.900, "x": 0.000}},
        {"array": "bottom",
         "pmt_position": 3,
         "position": {"y": 0.000, "x": 0.000}},
        {"array": "bottom",
         "pmt_position": 4,
         "position": {"y": -2.900, "x": 0.000}},
        {"array": "bottom",
         "pmt_position": 5,
         "position": {"y": -1.450, "x": 2.900}},
        {"array": "bottom",
         "pmt_position": 6,
         "position": {"y": 1.450, "x": 2.900}},
        {"array": "top",
         "pmt_position": 7,
         "position": {"y": -1.450, "x": -2.900}},
        {"array": "top",
         "pmt_position": 8,
         "position": {"y": 1.450, "x": -2.900}},
        {"array": "top",
         "pmt_position": 9,
         "position": {"y": 2.900, "x": 0.000}},
        {"array": "top",
         "pmt_position": 10,
         "position": {"y": 0.000, "x": 0.000}},
        {"array": "top",
         "pmt_position": 11,
         "position": {"y": -2.900, "x": 0.000}},
        {"array": "top",
         "pmt_position": 12,
         "position": {"y": -1.450, "x": 2.900}},
        {"array": "top",
         "pmt_position": 13,
         "position": {"y": 1.450, "x": 2.900}}
       ]

# These gains are placeholder for gain calibration
gains = [
             # 0               # 1               # 2               # 3               # 4
       3200000.0,        2590000.0,        2490000.0,        2630000.0,        3000000.0,
             # 5               # 6               # 7               # 8               # 9
       2000000.0,        2410000.0,        3150000.0,        3000000.0,        3050000.0,
            # 10              # 11              # 12              # 13
       2800000.0,        3190000.0,        3220000.0,        2800000.0,
	    ]

gain_sigmas =   [
             # 0               # 1               # 2               # 3               # 4
       1600000.0,        1490000.0,        1900000.0,        2190000.0,        2000000.0,
             # 5               # 6               # 7               # 8               # 9
       2000000.0,        2000000.0,        1600000.0,        2500000.0,        2260000.0,
            # 10              # 11              # 12              # 13
       2200000.0,        1640000.0,        2070000.0,        1750000.0,
		        ]

# Preference in algorithms to use for the xy reconstructed position
# used in buildinteractions and peakareacorrections
xy_posrec_preference = ['PosRecMaxPMT', 'PosRecTopPatternFit', 'PosRecNeuralNet',
                        'PosRecRobustWeightedMean', 'PosRecWeightedSum']

[EVE_file.EveInput]
Channel_to_PMT_mapping =
    {0 : 0,
    1 : 1,
    2 : 2,
    3 : 3,
    4 : 4,
    5 : 5,
    6 : 6,
    7 : 7,
    8 : 8,
    9 : 9,
    10 : 10,
    11 : 11,
    12 : 12,
    13 : 13}




[Plotting]
waveforms_to_plot = (
                    {'internal_name': 'tpc',      'plot_label': 'TPC (hits only)',
                    'drawstyle': 'steps',         'color':'black'},
                    )
[HitFinder.FindHits]
# Compute baseline on first n samples in pulse:
initial_baseline_samples = 20   # When using ZLE this must not be higher than 2x zle_nlbk as the peaks will be counted in otherwise
height_over_noise_high_threshold = 5
height_over_noise_low_threshold = 1
# Compute baseline on first n samples in pulse:

# Max hits to look for in each pulse: rest will be ignored
max_hits_per_pulse = 500

# Diagnostic plots settings
make_diagnostic_plots = 'never'     # Can be always, never, tricky cases, no hits, hits only, saturated
make_diagnostic_plots_in = 'hitfinder_diagnostic_plots'
# Add extra information to diagnostic plots - this gives info on sum of hits in one pulse
diagnostic_plot_info = 'yes' # can be yes or no

# Threshold 2: Absolute ADC counts above baseline
absolute_adc_counts_high_threshold = 1   # ADC counts
absolute_adc_counts_low_threshold = 1   # ADC counts


# Threshold 3:  - Height / minimum
height_over_min_high_threshold = 2
height_over_min_low_threshold = 0

# Raise low threshold temporarily to fraction of hit height for rest of pulse
dynamic_low_threshold_coeff = 0.01


[Cluster]
# Suspicious channel rejection settings
penalty_per_noise_pulse = 1                 # "pe" equivalent penalty
penalty_per_lone_hit = 1                    # "pe" equivalent penalty
# Threshold to mark a suspicious channel
penalty_geq_this_is_suspicious = 3          # "pe" equivalent penalty

# If the ratio of noise channels / contributing channels is larger than this, classify peak as 'noise'
# noise channel = a channel in the same detector which shows data, but doesn't contribute to the peak
# (or only hits rejected by the suspicious channel algorithm)
max_noise_channels_over_contributing_channels = 2

[Cluster.MeanShift]
s2_size = 20
# If spe peaks are separated by less than this, they will be clustered together
s2_width = 1.0 * us
p_value = 0.999
cluster_all = True

[Cluster.HitDifference]
max_difference = 2 * ns

[BuildPeaks.GapSizeClustering]
# Start a new cluster / peak if a gap larger than this is encountered
# see [note tbd]
max_gap_size_in_cluster = 10 * ns

[RejectNoiseHits]
# Suspicious channel rejection settings
penalty_per_noise_pulse = 0                 # "pe" equivalent penalty
penalty_per_lone_hit = 1                    # "pe" equivalent penalty

# Threshold to mark a suspicious channel
penalty_geq_this_is_suspicious = 3          # "pe" equivalent penalty

# Very dodgy channels start with a base penalty to make them always suspicious
# This means they will contribute only if non-suspicious channels in the same detector show > 3pe area
# Dodgy channels selected using run 10 noisy AmBe (120402_2000)
base_penalties = {
                 }
[BuildInteractions.BuildInteractions]
# Pair S1s and S2s in order of size, but no more than these:
pair_n_s2s = 5
pair_n_s1s = 3

# Never pair S2s smaller than:
s2_pairing_threshold = 70  # pe


[Table.TableWriter]
#output_format = 'hdf5_pandas'      # hdf5, csv, numpy, html, json, root, hdf5_pandas
# Don't leave out hits and pulses -- that's what we're after!
fields_to_ignore = ['sum_waveforms',
                   'channel_waveforms',
                   #'all_hits',
                   'raw_data',
                   'hits',
                   #'peaks',
                   #'pulses',
                   'detector',
                   'n_reconstructed_positions',
                   'reconstructed_positions_start',
                   'area_fraction_top',
                   'area_midpoint',
                   'area_per_channel',
                   'birthing_split_fraction',
                   'birthing_split_goodness',
                   'bottom_hitpattern_spread',
                   'hit_time_mean',
                   'hit_time_std',
                   'hits_fraction_top',
                   'interior_split_fraction',
                   'interior_split_goodness',
                   'left',
                   'lone_hit_channel',
                   'mean_amplitude_to_noise',
                   'n_hits',
                   'n_noise_pulses',
                   'n_saturated_channels',
                   'n_saturated_per_channel',
                   'n_saturated_samples',
                   'range_area_decile',
                   'right',
                   'sum_waveform',
                   'sum_waveform_top',
                   'top_hitpattern_spread',
                   ]

[WaveformSimulator]
s2_patterns_file = None
s1_patterns_file = None
# Waveform building / noise simulation settings
                                            # Set to None or False if you don't want to use real noise
real_noise_sample_size =              150                # Data is concatenated in noise file: this specifies original sample size. We'll take these samples and shuffle them.

# Slow control data
pressure =                            2.22 * bar          # xenon:xenon1t:analysis:maxime:liquidlevelandpressureanalysis, also in slow control / run database
temperature =                         (-89.32 + 273.15) * K    # InsideBell temperature, xenon:xenon100:analysis:stability_run10
anode_voltage =                       4.0 * kV            # Slow control / run database (early run10)

# PMT characteristics
pmt_transit_time_mean     =           50  * ns           # PLACEHOLDER - PMT handbook upper limit for linear focussed pmt type
                                                         # Not a big issue I think, this merely shifts the entire waveform. Could even put it 0.
pmt_transit_time_spread   =           0.8 * ns           # xenon:xenon100:pmtdatasheets, Room temperature
pmt_rise_time             =           1.8 * ns           # xenon:xenon100:pmtdatasheets, Room temperature
pmt_fall_time             =           6.7 * ns           # PLACEHOLDER - Can't find this! Now chosen 3.7 * rise time, as for Lung et al. 2012 (X1T PMTs)
    # Note this pmt pulse shape is probably not accurate, even besides the uncertain parameters, the amplifier & digitizer also shape the pulse.
    # Guillaume's fadc.py / spe.py has 4ns as the RC time for the digitizer, so not a big effect?

# Currently only used for s1 time structure calculations:
drift_field =                         530 * V /cm        # TODO add ref ('The xenon100 experiment'?)
liquid_density =                      3 * g / cm**3      # PLACEHOLDER

# S2 electron drift and extraction
drift_velocity_liquid_above_gate =    0.272*cm/us        # From the single electron paper
diffusion_constant_liquid =           12*cm**(2)/s       # Sorensen 2011, longitudinal diffusion. Ethan's code uses 70*cm**(2)/s! (0.007*mm**2/us)
electron_extraction_yield =           1                  # "above 0.96" xenon:xenon100:analysis:maxime:s2afterpulses
gate_to_anode_distance =              5 * mm             # See e.g. single electron paper, several other places

# S2 electroluminescence
elr_gas_gap_length =                  4.0 * mm            # Jelle: Fit to Xenon100 single-e S2s xenon:xenon100:analysis:single_e_waveform_model
                                                          # Xenon100 Analysis paper, page 4, "h_g ~ 2.5 mm"
s2_secondary_sc_gain_density =        19.7/(4.0*mm)       # "secondary scintillation gain" per length unit. 19.7 from NSort.
                                                          # TODO: this should NOT include zero-length encoding & hitfinder effects, i.e. has to be corrected from measured value!!
# Distance from anode where field becomes wire-like (~1/r) rather than uniform:
anode_field_domination_distance =     0.65 * mm           # Jelle: Fit to Xenon100 single-e S2s xenon:xenon100:analysis:single_e_waveform_model
# Distance from anode where field stops:
anode_wire_radius =                   125/2 * um          # GPlante p 98


s1_detection_efficiency =             0.08                # NSort. This should include LCE and QE effects, but not zero-length encoding / hitfinder acceptance.

s1_patterns_zoom_factor = 1                   # Use a very zoomed-out map for patternfitter performance

s2_mean_area_fraction_top =           0.555               # S2 asymmetry average = 0.11, top fraction = (1 + A)/2. Todo: check / add ref!

quantum_efficiencies = [
        0.        ,  0.245     ,  0.264     ,  0.237     ,  0.241     ,
        0.252     ,  0.252     ,  0.234     ,  0.23      ,  0.241     ,
        0.241     ,  0.237     ,  0.26      ,  0.249     ,  0.252     ,
        0.264     ,  0.241     ,  0.256     ,  0.245     ,  0.245     ,
        0.256     ,  0.234     ,  0.241     ,  0.253     ,  0.23      ,
        0.245     ,  0.241     ,  0.241     ,  0.256     ,  0.249     ,
        0.237     ,  0.237     ,  0.256     ,  0.256     ,  0.252     ,
        0.249     ,  0.245     ,  0.245     ,  0.249     ,  0.241     ,
        0.267     ,  0.256     ,  0.256     ,  0.267     ,  0.241     ,
        0.23      ,  0.237     ,  0.252     ,  0.256     ,  0.231     ,
        0.237     ,  0.237     ,  0.252     ,  0.241     ,  0.275     ,
        0.237     ,  0.245     ,  0.249     ,  0.24355102,  0.215     ,
        0.241     ,  0.26      ,  0.249     ,  0.222     ,  0.249     ,
        0.249     ,  0.264     ,  0.241     ,  0.237     ,  0.226     ,
        0.237     ,  0.264     ,  0.252     ,  0.267     ,  0.249     ,
        0.256     ,  0.252     ,  0.241     ,  0.245     ,  0.241     ,
        0.241     ,  0.237     ,  0.249     ,  0.245     ,  0.245     ,
        0.264     ,  0.264     ,  0.241     ,  0.249     ,  0.252     ,
        0.23      ,  0.226     ,  0.23      ,  0.245     ,  0.252     ,
        0.267     ,  0.245     ,  0.23      ,  0.234     ,  0.29      ,
        0.2902381 ,  0.2902381 ,  0.276     ,  0.241     ,  0.311     ,
        0.2902381 ,  0.2902381 ,  0.324     ,  0.2902381 ,  0.246     ,
        0.242     ,  0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.2902381 ,  0.238     ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.31      ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.352     ,  0.2902381 ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.325     ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.355     ,  0.2902381 ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.2902381 ,  0.271     ,  0.271     ,
        0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,  0.2902381 ,
        0.2902381 ,  0.2902381 ,  0.342     ,  0.358     ,  0.294     ,
        0.237     ,  0.275     ,  0.291     ,  0.246     ,  0.235     ,
        0.234     ,  0.246     ,  0.239     ,  0.242     ,  0.26      ,
        0.229     ,  0.247     ,  0.245     ,  0.246     ,  0.226     ,
        0.245     ,  0.234     ,  0.23      ,  0.238     ,  0.256     ,
        0.259     ,  0.241     ,  0.23      ,  0.238     ,  0.258     ,
        0.266     ,  0.208     ,  0.235     ,  0.241     ,  0.252     ,
        0.256     ,  0.26      ,  0.245     ,  0.246     ,  0.226     ,
        0.256     ,  0.229     ,  0.214     ,  0.211     ,  0.215     ,
        0.241     ,  0.235     ,  0.237     ,  0.225     ,  0.204     ,
        0.256     ,  0.224     ,  0.264     ,  0.241     ,  0.232     ,
        0.209     ,  0.218     ,  0.221     ,  0.214     ,  0.267     ,
        0.205     ,  0.245     ,  0.222     ,  0.214     ,  0.23734921,
        0.251     ,  0.225     ,  0.245     ,  0.203     ,  0.271     ,
        0.245     ,  0.264     ,  0.237     ]

# Relative error / uncertainty on QE
# TODO: remove placeholder
relative_qe_error = 0.02

# Relative error / uncertainty on gains
# Note this is NOT the spread of the 1pe gain spectrum! (gain_sigmas above)
relative_gain_error = 0.03    # Systmatic of PMT gain calibration. TODO: add ref.


[BasicProperties.SumWaveformProperties]
# Length of the peak sum waveform field.
# Must be an even multiple of sample size, pax will add 1 sample width so there is a clear center.
peak_waveform_length = 2.5 * us
